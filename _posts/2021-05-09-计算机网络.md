---
layout:     post
title:      计算机网络基础
subtitle:   TCP协议
date:       2021-05-09
author:     Uarealoser
header-img: img/post-bg-swift.jpg
catalog: true
tags:
    - network
---

# 1. 传输层

传输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能的最底层。网络层为主机之间提供逻辑通信，而传输层为进程之间提供端到端的逻辑通信。

传输层向高层用户屏蔽了下面的网络核心细节(如网络拓扑，所采用的路由选择协议等)，它使进程看起来就好像在两个传输层实体之间有一条端到端的逻辑通信信道。当传输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的(只提供尽最大努力交付)。

传输层的两个主要协议：

- 用户数据报协议：UDP(User Datagram Protocol)
- 传输控制协议：TCP(Transmission Control Protocol)

## 2. TCP

## 2.1 TCP的主要特点

- TCP是面向连接的传输协议
- 每一个TCP连接只能有2个端点
- TCP提供可靠交付服务(无差错，不丢失，不重复，按序到达)。
- 全双工通信：TCP允许通信双方的应用进程任何时候都能发送数据。TCP连接的两端都有发送缓存和接收缓存，在发送时，应用程序只需要把数据传送到TCP发送缓存中，在接收时，TCP把收到的数据放入接收缓存，上层应用可以随时读取。
- 面向字节流：虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交付下来的数据仅仅看成一连串的**无结构的字节流**(例如，发送方交给发送方TCP10个数据块，但接收方的TCP可能只用4个数据块就把收到的字节流交付给了上层)。

TCP连接的含义：每一条TCP连接唯一的被通信两端的两个端点，即套接字(ip:port)所确定。

## 2.2 可靠传输原理

### 2.2.1 停止等待协议

停止等待：就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。

#### 2.2.1.1 无差错情况

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc5m2x18kj307r08pq2v.jpg)

#### 2.2.1.2 出现差错

- **超时重传**

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc5mma3r5j309v08yt8p.jpg)

在上图中，B接收M1时出现差错，就丢弃M1(不通知A收到有差错的分组)。

超时重传：A只要查过一段时间仍然没有收到B的确认，就认为刚才发送的分组丢失了，因而重传丢失的分组。

超时计时器：要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。

- A发送完一个分组后，必须保存该分组副本
- 分组和确认分组都必须进行编号
- 超时计时器应该比分组传输平均往返时间更长一点

- **确认丢失**

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc5sxy0s4j30ap08wt8o.jpg)

- **确认迟到**

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc5ta40wrj30au08kjrf.jpg)


### 2.2.2 连续ARQ协议

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc5wg5c5vj30fm08lq34.jpg)

它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认。以提高信道利用率。

连续ARQ协议规定：发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

接收方一般都采用累计确认机制：也就是说接收方不必对收到的分组逐个发送确认，而是收到几个分组后，对按序到达的最后一个分组发送确认。

连续ARQ的问题：如果发送方发送了5个分组，而中间2个分组丢失，这是接收方只能对前两个分组确认，而重传后3个分组，这就叫做**回退N**，由此可见，当线路质量不好时，连续ARQ会带来负面影响。

## 2.3 TCP报文段首部格式

TCP虽然是面向字节流的，但TCP传送数据单元却是报文段。

TCP报文段首部的前20字节是固定的，后面有4n字节是根据需要而增加的选项。因此TCP首部最小长度是20字节。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc653q8dlj30k90f5wf9.jpg)

- 源端口和目的端口：2字节
- 序号：4字节
- 确认号：4字节，是期望收到对方下一个报文段的第一个数据字节的序号(B收到序号为501，报文段长度为200字节的分组，这时返回给A的序列号为701)
- 数据偏移：4位，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。即TCP报文段首部长度。其单位为4字节(32位)，而4位表示的最大二进制是15，因此TCP首部最长为15*4=60字节。
- 保留：6位
- 紧急URG：为1时，表明该分组是紧急字段。
- 确认ACK：ACK =1时，确认号才有效。
- 推送PUSH：表明尽快交付
- 复位RST：TCP存在严重差错，需要释放连接重新建立。
- 同步SYN：在连接建立时，用来同步序号。SYN = 1，ACK = 0，表明是一个连接请求。
- 终止FIN：释放连接
- 窗口：2字节，窗口指的是发送本报文段一方的接收窗口(不是发送窗口)，其中的值代表：从本报文段首部中确认号算起，接收方目前允许对方发送的数据量(以字节为单位)。
- 校验和：2字节
- 紧急指针：2字节，URG =1 有效
- 选项：长度变，最长40字节。(例如规定最大报文段长度MSS,该长度是指减去首部后的长度)

## 2.4 TCP可靠传输的实现

### 2.4.1 以字节为单位的滑动窗口

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc6qbwk56j30ln074t91.jpg)

发送窗口：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过去的数据，在未收到确认之前，都必须保留，以便在超时重传时使用。

发送窗口的位置由窗口前沿后后沿位置共同确定

- 后沿：

    - 不动：没有收到新的确认
    - 前移：收到了新的确认
    
- 前沿：发送窗口前沿着一般是不断向前移动的，但也有不动的情况

    - 没有收到新的确认，对方通知的窗口大小也每变
    - 收到了新的确认，但是对方通知的窗口也变小了
    
### 2.4.2 选择确认SACK

若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据。那么如何只重传缺少的数据呢？

![](https://tva1.sinaimg.cn/large/008i3skNly1gqc6z8dranj30kk04wglo.jpg)

从图可以看出，前后字节不连续的标记共需要4个边界值，此时在TCP首部中开启允许使用选择确认SACK，同时将边界值写入选项字段(每个边界值会占用4个字节，因此最多写入4个边界值)

## 2.5 TCP的流量控制

### 2.5.1 利用滑动窗口实现流量控制

一般来说，我们总是希望数据传输的更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，就会造成数据的丢失。

所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接收。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqccgs7pjgj30jj0c2757.jpg)

因此，发送方的发送窗口不能超过接收方的接收窗口的数值，且TCP窗口的单位是字节，不是报文段。

## 2.5 TCP的拥塞控制

所谓拥塞控制，就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

TCP进行拥塞控制的算法分为4种，即：

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

### 2.5.1 基于窗口拥塞控制

基于窗口的拥塞控制：发送方维持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是：只要网络没有出现阻塞，拥塞窗口就可以一再增大，以便把更多的分组发送出去，这样可以提高网络的利用率。但只要网络出现拥塞或者可能出现拥塞，就必须把拥塞窗口减小一些。

发送发如何知道网络发生了拥塞？

当网络发生拥塞时，路由器就要丢弃分组。因此只要发送方没有按时收到应当到达的确认报文，就可以猜想网络可能发生了拥塞。

### 2.5.2 慢开始

当主机开始发送数据时，由于并不清除网络的负载情况，较好的方式是由小到大的逐渐增大发送窗口，即由小到大的增大拥塞窗口的数值。

旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口设置为1至2个发送方的最大报文段SMSS(Sender Maximum Segment Size)的数值。
新的RFC 5681规定：

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcj7zsaz8j30k005f3yu.jpg)

慢开始规定：在每一个收到对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcja7iadmj30if0a4dg9.jpg)

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。

- 当cwnd<ssthresh时，使用慢开始算法
- cwnd>ssthresh,停止使用慢开始，而该用拥塞避免算法
- cwnd=ssthresh,既可以使用慢开始，也可以拥塞避免

### 2.5.3 拥塞避免

拥塞避免算法的思路是让拥塞窗口cwnd缓慢的增大，即每增加一个往返时间RTT就把发送方的拥塞窗口cwnd+1,而不是像慢开始阶段那样加倍增长。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcjgn2zwsj30ln089q39.jpg)

当拥塞窗口cwnd = 24时，网络出现了超时，发送方判读为网络拥塞。于是调整慢开始门限ssthresh= cwnd/2 = 12,同时设置拥塞窗口cwnd= 1,进入慢开始阶段。

### 2.5.4 快重传

有时候，个别的网络报文丢失并不是发生了网络拥塞，如果总是重新进行慢开始，把cwnd设置为1，就会降低网络的传输效率。

快重传算法首先要求接收方不要等待自己发送数据时才进行ack的捎带确认，而是要立即发送确认。即使收到失序的报文段也要立即发出对已收到的报文段的重复确认。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcjoeowj0j30hl09dq3a.jpg)

发送方只要一连收到3个重复确认，就知道对方没有收到对应的报文段，因而应当立即进行重传。

因此，发送方在知道只是个别报文段丢失的情况下，并不实用慢开始，而是执行快恢复算法。这时，发送方调整慢开始门限ssthresh = cwnd/2 = 8,同时设置拥塞窗口cwnd = ssthresh = 8,并开始执行拥塞避免。

## 2.6 TCP的传输连接管理

TCP连接的建立采用客户服务器模式，主动发起连接建立的应用程序叫做客户端(cli),而被动等待连接建立的应用程序叫做服务器(server)

### 2.6.1 TCP连接建立

TCP连接建立的阶段叫做握手，握手需要客户端和服务器之间交换3个报文段。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcjypmbaqj30iq0bwaag.jpg)

客户端：

- 发送SYN=1，序号为x的分组,此时客户端处于SYN-SENT(同步已发送)阶段。
- 收到服务端SYN=1,ACK=1，序号为y，确认号为x+1的分组
- 发送ACK=1，序号为x+1，确认号为y+1的分组，此时客户端处于ESTABLISHED阶段，对于客户端，认为连接建立完成。

服务端：

- 开始时，需要进行TCP端口监听，处于LISTEN阶段
- 收到客户端发来的连接建立请求分组，SYN=1，序号为x的分组
- 对收到的分组发送确认：SYN=1，ACK=1，序号y，确认号x+1，代表已经收到x分组，此时服务端进入SYN-RCVD(同步已收到)阶段
- 收到客户端对确认的确认，ACK=1，序号为x+1，确认号为y+1的分组，服务端处于ESTABLISHD阶段，此时服务端认为，连接建立完成。

TCP规定：SYN报文段(即SYN=1),不能携带数据，但是需要消耗掉一个序号。

#### 2.6.1.1 为什么一定需要三次握手？

为什么A最后还要发送一次确认呢？

**主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。**

已失效的报文段：A发送连接请求，但因为请求报文丢失而重传了连接请求，后来收到了确认，建立了连接，完成传输并释放。但是如果第一个请求报文并没有丢失，而是延迟导致过了很久才到达B，此时B再次收到该报文端，就误认为A重新发起了连接请求，如果没有3次握手的存在，对于这一次请求，虽然A并不是要建立连接，但还是误建了连接。

### 2.6.2 TCP连接的释放

A，B数据传输完成，A，B都处于ESTABLISH状态。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqcki9gdl3j30jq0dv74w.jpg)

客户端：处于ESTABLISH状态下，主动关闭

- 发送FIN=1，序号u分组，进入FIN-WAIT-1(终止等待1)状态
- 收到服务端发送的确认ACK=1，序号为v，确认号为u+1的分组，进入FIN-WAIT-2(终止等待2)
- 收到服务端发送的释放连接请求FIN=1，ACK=1，序号w，确认号u+1的分组，进入TIME-WAIT(时间等待)状态，并等待时间等待计数器设置的2MSL后，客户端进入CLOSED状态

服务端：处于ESTABLISH状态下被动关闭

- 收到客户端发送的释放连接请求，FIN=1，序号u的分组
- 发送连接释放请求确认，ACK=1，序号v，确认好u+1，进入CLOSE-WAIT(关闭等待)状态
- 继续传输一些需要传输给客户端的数据
- 传输完毕，发送服务端到客户端的释放连接请求。FIN=1，ACK=1，序号为w，确认号为u+1，进入LASK-ACK(最终确认)状态
- 收到客户端对服务端释放连接请求的相应，ACK=1，序号u+1，确认号w+1，立即关闭服务端到客户端的连接

#### 2.6.3 为什么客户端需要等待2MSL？

- 为了保证A发送的最后一个ACK报文段能够到达B
- 防止已失效的连接请求报文出现。A在发送完最后一个确认ACK后，等待2MSL，就可以使本次连接持续时间内所产生的请求所有报文段都从网络中消失。

#### 2.6.4 保活计时器

除了时间等待计时器，TCP还设有一个保活计时器，即每收到一个客户端的确认，就重置该计时器，默认如果超过2个小时没有收到客户端数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次，一直发送10次，若客户端仍然没有响应，服务段就关闭该连接。

## 2.6 TCP的有限状态机

![](https://tva1.sinaimg.cn/large/008i3skNly1gqclwtk31wj30kj0llt9v.jpg)