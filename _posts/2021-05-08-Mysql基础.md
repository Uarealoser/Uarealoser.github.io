---
layout:     post
title:      Mysql基础
subtitle:   表与索引
date:       2021-05-08
author:     Uarealoser
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - mysql
---

# 表

## 索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表被称为索引组织表。

在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显式定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：

- 首先判断表中是否存在非空的唯一索引，如果有，则该列为主键。
- 如果没有，InnoDB存储引擎自动创建一个6字节大小的指针。

## InnoDB逻辑存储结构

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb0q7r3okj30w00lp0ts.jpg)

从InnoDB存储引擎的逻辑存储结构来看，所有的数据都被存放在一个空间中，称为表空间(tablespace)。

表空间又由段(segment),区(extent),页(page)组成。

- 表空间

所有的数据都存放在表空间中，默认有一个共享表空间ibdata1,即所有数据存放在该表空间中。

- 段

表空间由各个段组成，常见有数据段，索引段，回滚段等。

对于innodb，数据即索引，索引即数据。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

- 区

区是由连续的页组成的空间，任何情况下，每个区的大小都是1MB。

默认情况下，InnoDB存储引擎页的大小为16KB，即一个区一共有64个页。

- 页(块)

页是InnoDB磁盘管理的最小单位。(最小磁盘单位)

默认为16kb，也可以通过参数设置成4kb，8kb。

在InnoDB存储引擎中，常见的页类型有：   
    •数据页（B-tree Node）  
    •undo页（undo Log Page）   
    •系统页（System Page）   
    •事务数据页（Transaction system Page）   
    •插入缓冲位图页（Insert Buffer Bitmap）   
    •插入缓冲空闲列表页（Insert Buffer Free List）   
    •未压缩的二进制大对象页（Uncompressed BLOB Page）   
    •压缩的二进制大对象页（compressed BLOB Page）
    
- 行

InnoDB存储引擎是面向行的，即数据是按行存放的。每个页存放的行记录最多允许存放7992行记录。

## InnoDB数据页结构

页是InnoDB最小磁盘单位。页类型为B-tree Node的页存放的即是表中行的实际数据了。

InnoDB数据页由以下7个部分组成：

- File Header（文件头）   
- Page Header（页头）   
- Infimun和Supremum Records   
- User Records（用户记录，即行记录）   
- Free Space（空闲空间）   
- Page Directory（页目录）   
- File Trailer（文件结尾信息）

其中File Header、Page Header、File Trailer的大小是固定的，分别为38、56、8字节。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb16k3wimj30w00timy2.jpg)

# 索引

InnoDB存储引擎支持以下几种常见的索引：

- B+树索引：B+树索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。（B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。）
- 全文索引：
- 哈希索引：InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

## B+树

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb1e3ynfjj30w008f74i.jpg)

上图是一个高度为2的B+树，每页可以存放4条记录，扇出为5。

所有记录都在叶子节点上，并且是顺序存放的，如果用户从最左边的叶子节点开始顺序遍历，可以得到所有键值的顺序排序：5、10、15、20、25、30、50、55、60、65、75、80、85、90。

B+索引在数据库中有一个特点是高扇出性，因此在数据库中，B+树的高度一般都在2～4层，这也就是说查找某一键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械磁盘每秒至少可以做100次IO，2～4次的IO意味着查询时间只需0.02～0.04秒。

数据库中的B+树索引可以分为聚集索引（clustered inex）和辅助索引（secondary index），但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

## 聚集索引

InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。

而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。每个数据页都通过一个双向链表来进行链接。

由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。

数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb1mbebe2j30w00gu75a.jpg)

注意：聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。

## 辅助索引

对于辅助索引（Secondary Index，也称非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。

由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。

查找过程：当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

举个栗子：如果在一棵高度为3的辅助索引树中查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页。

## B+树索引的使用

### 联合索引

联合索引是指对表上的多个列进行索引。

```mysql
CREATE TABLE t (
   a INT,
   b INT,
   PRIMARY KEY (a),
   KEY idx_a_b ( a,b)
)ENGINE=INNODB
```

从本质上来说，联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb1tpnuz2j30w00atmxd.jpg)

通过叶子节点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1，1）、（1，2）、（2，1）、（2，4）、（3，1）、（3，2）。数据按（a, b）的顺序进行了存放。

对于b列的查询SELECT*FROM TABLE WHEREb=xxx，则不可以使用这棵B+树索引。可以发现叶子节点上的b值为1、2、1、4、1、2，显然不是排序的，因此对于b列的查询使用不到（a, b）的索引。

什么时候使用联合索引？

联合索引（a, b）其实是根据列a、b进行排序，因此下列语句可以直接使用联合索引得到结果：索引查出来的值已经排好序了，减少了一次排序过程。

```mysql
SELECT ... FROM TABLE WHERE a=xxx ORDER BY b
```

对于联合索引（a, b，c）来说：

```mysql
SELECT ... FROM TABLE WHERE a=xxx ORDER BY b
SELECT ... FROM TABLE WHERE a=xxx AND b=xxx ORDER BY c
```

### 覆盖索引

InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录，优先走辅助索引。

使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

### 优化器不选择使用辅助索引的情况

用户要选取的数据是整行信息，而OrderID索引不能覆盖到我们要查询的信息，因此在对OrderID索引查询到指定数据后，还需要一次书签访问来查找整行数据的信息。虽然OrderID索引中数据是顺序存放的，但是再一次进行书签查找的数据则是无序的，因此变为了磁盘上的离散读操作。如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。因为之前已经提到过，顺序读要远远快于离散读。

即通过辅助索引并不能得到完整的查询信息，如果强行走辅助索引，就会造成顺序读到辅助索引后，由于不能得到完整的查询信息，就还需要通过其包含的主键key值，离散的查找主键索引行记录。多了一次离散IO。

### 索引提示

MySQL数据库支持索引提示（INDEX HINT），显式地告诉优化器使用哪个索引。

- MySQL数据库的优化器错误地选择了某个索引，导致SQL语句运行的很慢。这种情况在最新的MySQL数据库版本中非常非常的少见。
- 某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。

## 全文索引

B+树索引的特点，可以通过索引字段的前缀（prefix）进行查找。例如，对于下面的查询B+树索引是支持的：

```mysql
SELECT * FROM blog WHERE content like 'xxx%'
```

然而，通过这种情况，就无法使用B+树索引了：

```mysql
SELECT * FROM blog WHERE content like '%xxx%'
```

### 倒排索引

全文检索通常使用倒排索引（inverted index）来实现。倒排索引同B+树索引一样，也是一种索引结构。

它在辅助表（auxil-iary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：

- inverted file index，其表现形式为{单词，单词所在文档的ID}
- full invertedindex，其表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb2drghntj30w004vdg7.jpg)

DocumentId表示进行全文检索文档的Id，Text表示存储的内容，用户需要对存储的这些文档内容进行全文检索。例如，查找出现过Some单词的文档Id，又或者查找单个文档中出现过两个Some单词的文档Id，等等。

![](https://tva1.sinaimg.cn/large/008i3skNly1gqb2f5eaihj30w0092dgh.jpg)

### InnoDB全文检索

在InnoDB存储引擎中，将（DocumentId, Position）视为一个“ilist”。因此在全文检索的表中，有两个列，一个是word字段，另一个是ilist字段，**并且在word字段上有设有索引。**

